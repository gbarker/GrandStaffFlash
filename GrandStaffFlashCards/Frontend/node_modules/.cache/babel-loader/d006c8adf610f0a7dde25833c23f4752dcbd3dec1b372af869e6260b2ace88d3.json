{"ast":null,"code":"import { createStore } from 'vuex';\nimport axios from 'axios';\n\n// For development, we'll use mock data\n// In a real application, this would be replaced with API calls\nconst API_URL = 'http://localhost:5000/api';\nexport default createStore({\n  state: {\n    decks: [],\n    currentDeck: null,\n    currentCard: null,\n    cardHistory: [],\n    isLoading: false,\n    error: null\n  },\n  getters: {\n    allDecks: state => state.decks,\n    currentDeck: state => state.currentDeck,\n    currentCard: state => state.currentCard,\n    cardHistory: state => state.cardHistory,\n    isLoading: state => state.isLoading,\n    hasError: state => state.error !== null,\n    errorMessage: state => state.error\n  },\n  mutations: {\n    SET_DECKS(state, decks) {\n      state.decks = decks;\n    },\n    SET_CURRENT_DECK(state, deck) {\n      state.currentDeck = deck;\n    },\n    SET_CURRENT_CARD(state, card) {\n      state.currentCard = card;\n      state.cardHistory.push(card);\n    },\n    CLEAR_CARD_HISTORY(state) {\n      state.cardHistory = [];\n    },\n    SET_LOADING(state, isLoading) {\n      state.isLoading = isLoading;\n    },\n    SET_ERROR(state, error) {\n      state.error = error;\n    },\n    CLEAR_ERROR(state) {\n      state.error = null;\n    }\n  },\n  actions: {\n    // In a real application, these would make API calls\n    // For now, we'll use mock data\n    async fetchDecks({\n      commit\n    }) {\n      commit('SET_LOADING', true);\n      commit('CLEAR_ERROR');\n      try {\n        // Mock API call\n        // const response = await axios.get(`${API_URL}/decks`)\n        // commit('SET_DECKS', response.data)\n\n        // Mock data\n        const mockDecks = [{\n          id: '1',\n          name: 'Grand Staff Notes',\n          description: 'Learn to identify notes on the grand staff',\n          cardCount: 42\n        }];\n        commit('SET_DECKS', mockDecks);\n      } catch (error) {\n        commit('SET_ERROR', error.message || 'Failed to fetch decks');\n      } finally {\n        commit('SET_LOADING', false);\n      }\n    },\n    async fetchDeck({\n      commit\n    }, deckId) {\n      commit('SET_LOADING', true);\n      commit('CLEAR_ERROR');\n      try {\n        // Mock API call\n        // const response = await axios.get(`${API_URL}/decks/${deckId}`)\n        // commit('SET_CURRENT_DECK', response.data)\n\n        // Mock data\n        const mockDeck = {\n          id: '1',\n          name: 'Grand Staff Notes',\n          description: 'Learn to identify notes on the grand staff',\n          cards: generateMockCards()\n        };\n        commit('SET_CURRENT_DECK', mockDeck);\n      } catch (error) {\n        commit('SET_ERROR', error.message || 'Failed to fetch deck');\n      } finally {\n        commit('SET_LOADING', false);\n      }\n    },\n    async getNextCard({\n      commit,\n      state\n    }) {\n      if (!state.currentDeck || !state.currentDeck.cards || state.currentDeck.cards.length === 0) {\n        commit('SET_ERROR', 'No cards available');\n        return;\n      }\n\n      // Get a random card from the deck\n      const randomIndex = Math.floor(Math.random() * state.currentDeck.cards.length);\n      const card = state.currentDeck.cards[randomIndex];\n      commit('SET_CURRENT_CARD', card);\n    },\n    async submitAnswer({\n      commit,\n      state,\n      dispatch\n    }, {\n      cardId,\n      answer,\n      isCorrect\n    }) {\n      if (!state.currentDeck || !state.currentCard) {\n        commit('SET_ERROR', 'No active card');\n        return;\n      }\n      try {\n        // In a real app, we would call the API to record the answer\n        // await axios.post(`${API_URL}/decks/${state.currentDeck.id}/cards/${cardId}/answer`, {\n        //   answer,\n        //   isCorrect\n        // })\n\n        // If the answer was wrong, we would handle reshuffling the card\n        if (!isCorrect) {\n          // In a real app, this would be handled by the backend\n          // For now, we'll just get the next card\n        }\n\n        // Get the next card\n        dispatch('getNextCard');\n      } catch (error) {\n        commit('SET_ERROR', error.message || 'Failed to submit answer');\n      }\n    }\n  }\n});\n\n// Helper function to generate mock cards\nfunction generateMockCards() {\n  const notes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  const accidentals = ['', '#', 'b']; // Natural, Sharp, Flat\n  const keySignatures = ['C Major', 'G Major', 'F Major'];\n  const timeSignatures = ['4/4', '3/4', '6/8'];\n  const cards = [];\n  for (let i = 0; i < 15; i++) {\n    const noteIndex = Math.floor(Math.random() * notes.length);\n    const accidentalIndex = Math.floor(Math.random() * accidentals.length);\n    const keySignatureIndex = Math.floor(Math.random() * keySignatures.length);\n    const timeSignatureIndex = Math.floor(Math.random() * timeSignatures.length);\n\n    // Skip invalid combinations like B# and Cb\n    if (notes[noteIndex] === 'B' && accidentals[accidentalIndex] === '#' || notes[noteIndex] === 'C' && accidentals[accidentalIndex] === 'b' || notes[noteIndex] === 'E' && accidentals[accidentalIndex] === '#' || notes[noteIndex] === 'F' && accidentals[accidentalIndex] === 'b') {\n      i--;\n      continue;\n    }\n    const card = {\n      id: `card-${i + 1}`,\n      note: {\n        letter: notes[noteIndex],\n        accidental: accidentals[accidentalIndex],\n        octave: Math.floor(Math.random() * 3) + 3,\n        // Octaves 3-5\n        keySignature: keySignatures[keySignatureIndex],\n        timeSignature: timeSignatures[timeSignatureIndex]\n      },\n      correctCount: 0,\n      incorrectCount: 0\n    };\n    cards.push(card);\n  }\n  return cards;\n}","map":{"version":3,"names":["createStore","axios","API_URL","state","decks","currentDeck","currentCard","cardHistory","isLoading","error","getters","allDecks","hasError","errorMessage","mutations","SET_DECKS","SET_CURRENT_DECK","deck","SET_CURRENT_CARD","card","push","CLEAR_CARD_HISTORY","SET_LOADING","SET_ERROR","CLEAR_ERROR","actions","fetchDecks","commit","mockDecks","id","name","description","cardCount","message","fetchDeck","deckId","mockDeck","cards","generateMockCards","getNextCard","length","randomIndex","Math","floor","random","submitAnswer","dispatch","cardId","answer","isCorrect","notes","accidentals","keySignatures","timeSignatures","i","noteIndex","accidentalIndex","keySignatureIndex","timeSignatureIndex","note","letter","accidental","octave","keySignature","timeSignature","correctCount","incorrectCount"],"sources":["C:/Users/georg/Documents/Projects/Cursor Tutorial/GrandStaffFlashCards/Frontend/src/store/index.js"],"sourcesContent":["import { createStore } from 'vuex'\r\nimport axios from 'axios'\r\n\r\n// For development, we'll use mock data\r\n// In a real application, this would be replaced with API calls\r\nconst API_URL = 'http://localhost:5000/api'\r\n\r\nexport default createStore({\r\n  state: {\r\n    decks: [],\r\n    currentDeck: null,\r\n    currentCard: null,\r\n    cardHistory: [],\r\n    isLoading: false,\r\n    error: null\r\n  },\r\n  getters: {\r\n    allDecks: state => state.decks,\r\n    currentDeck: state => state.currentDeck,\r\n    currentCard: state => state.currentCard,\r\n    cardHistory: state => state.cardHistory,\r\n    isLoading: state => state.isLoading,\r\n    hasError: state => state.error !== null,\r\n    errorMessage: state => state.error\r\n  },\r\n  mutations: {\r\n    SET_DECKS(state, decks) {\r\n      state.decks = decks\r\n    },\r\n    SET_CURRENT_DECK(state, deck) {\r\n      state.currentDeck = deck\r\n    },\r\n    SET_CURRENT_CARD(state, card) {\r\n      state.currentCard = card\r\n      state.cardHistory.push(card)\r\n    },\r\n    CLEAR_CARD_HISTORY(state) {\r\n      state.cardHistory = []\r\n    },\r\n    SET_LOADING(state, isLoading) {\r\n      state.isLoading = isLoading\r\n    },\r\n    SET_ERROR(state, error) {\r\n      state.error = error\r\n    },\r\n    CLEAR_ERROR(state) {\r\n      state.error = null\r\n    }\r\n  },\r\n  actions: {\r\n    // In a real application, these would make API calls\r\n    // For now, we'll use mock data\r\n    async fetchDecks({ commit }) {\r\n      commit('SET_LOADING', true)\r\n      commit('CLEAR_ERROR')\r\n      \r\n      try {\r\n        // Mock API call\r\n        // const response = await axios.get(`${API_URL}/decks`)\r\n        // commit('SET_DECKS', response.data)\r\n        \r\n        // Mock data\r\n        const mockDecks = [\r\n          {\r\n            id: '1',\r\n            name: 'Grand Staff Notes',\r\n            description: 'Learn to identify notes on the grand staff',\r\n            cardCount: 42\r\n          }\r\n        ]\r\n        \r\n        commit('SET_DECKS', mockDecks)\r\n      } catch (error) {\r\n        commit('SET_ERROR', error.message || 'Failed to fetch decks')\r\n      } finally {\r\n        commit('SET_LOADING', false)\r\n      }\r\n    },\r\n    \r\n    async fetchDeck({ commit }, deckId) {\r\n      commit('SET_LOADING', true)\r\n      commit('CLEAR_ERROR')\r\n      \r\n      try {\r\n        // Mock API call\r\n        // const response = await axios.get(`${API_URL}/decks/${deckId}`)\r\n        // commit('SET_CURRENT_DECK', response.data)\r\n        \r\n        // Mock data\r\n        const mockDeck = {\r\n          id: '1',\r\n          name: 'Grand Staff Notes',\r\n          description: 'Learn to identify notes on the grand staff',\r\n          cards: generateMockCards()\r\n        }\r\n        \r\n        commit('SET_CURRENT_DECK', mockDeck)\r\n      } catch (error) {\r\n        commit('SET_ERROR', error.message || 'Failed to fetch deck')\r\n      } finally {\r\n        commit('SET_LOADING', false)\r\n      }\r\n    },\r\n    \r\n    async getNextCard({ commit, state }) {\r\n      if (!state.currentDeck || !state.currentDeck.cards || state.currentDeck.cards.length === 0) {\r\n        commit('SET_ERROR', 'No cards available')\r\n        return\r\n      }\r\n      \r\n      // Get a random card from the deck\r\n      const randomIndex = Math.floor(Math.random() * state.currentDeck.cards.length)\r\n      const card = state.currentDeck.cards[randomIndex]\r\n      \r\n      commit('SET_CURRENT_CARD', card)\r\n    },\r\n    \r\n    async submitAnswer({ commit, state, dispatch }, { cardId, answer, isCorrect }) {\r\n      if (!state.currentDeck || !state.currentCard) {\r\n        commit('SET_ERROR', 'No active card')\r\n        return\r\n      }\r\n      \r\n      try {\r\n        // In a real app, we would call the API to record the answer\r\n        // await axios.post(`${API_URL}/decks/${state.currentDeck.id}/cards/${cardId}/answer`, {\r\n        //   answer,\r\n        //   isCorrect\r\n        // })\r\n        \r\n        // If the answer was wrong, we would handle reshuffling the card\r\n        if (!isCorrect) {\r\n          // In a real app, this would be handled by the backend\r\n          // For now, we'll just get the next card\r\n        }\r\n        \r\n        // Get the next card\r\n        dispatch('getNextCard')\r\n      } catch (error) {\r\n        commit('SET_ERROR', error.message || 'Failed to submit answer')\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\n// Helper function to generate mock cards\r\nfunction generateMockCards() {\r\n  const notes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\r\n  const accidentals = ['', '#', 'b'] // Natural, Sharp, Flat\r\n  const keySignatures = ['C Major', 'G Major', 'F Major']\r\n  const timeSignatures = ['4/4', '3/4', '6/8']\r\n  \r\n  const cards = []\r\n  \r\n  for (let i = 0; i < 15; i++) {\r\n    const noteIndex = Math.floor(Math.random() * notes.length)\r\n    const accidentalIndex = Math.floor(Math.random() * accidentals.length)\r\n    const keySignatureIndex = Math.floor(Math.random() * keySignatures.length)\r\n    const timeSignatureIndex = Math.floor(Math.random() * timeSignatures.length)\r\n    \r\n    // Skip invalid combinations like B# and Cb\r\n    if ((notes[noteIndex] === 'B' && accidentals[accidentalIndex] === '#') ||\r\n        (notes[noteIndex] === 'C' && accidentals[accidentalIndex] === 'b') ||\r\n        (notes[noteIndex] === 'E' && accidentals[accidentalIndex] === '#') ||\r\n        (notes[noteIndex] === 'F' && accidentals[accidentalIndex] === 'b')) {\r\n      i--\r\n      continue\r\n    }\r\n    \r\n    const card = {\r\n      id: `card-${i + 1}`,\r\n      note: {\r\n        letter: notes[noteIndex],\r\n        accidental: accidentals[accidentalIndex],\r\n        octave: Math.floor(Math.random() * 3) + 3, // Octaves 3-5\r\n        keySignature: keySignatures[keySignatureIndex],\r\n        timeSignature: timeSignatures[timeSignatureIndex]\r\n      },\r\n      correctCount: 0,\r\n      incorrectCount: 0\r\n    }\r\n    \r\n    cards.push(card)\r\n  }\r\n  \r\n  return cards\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}