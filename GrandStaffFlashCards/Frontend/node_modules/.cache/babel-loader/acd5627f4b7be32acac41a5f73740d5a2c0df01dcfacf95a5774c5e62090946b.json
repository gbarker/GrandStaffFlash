{"ast":null,"code":"import { defineStore } from 'pinia';\nimport axios from 'axios';\n\n// Helper function to generate mock cards\nfunction generateMockCards() {\n  const notes = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  const accidentals = ['', '#', 'b']; // Natural, Sharp, Flat\n  const keySignatures = ['C Major', 'G Major', 'F Major'];\n  const timeSignatures = ['4/4', '3/4', '6/8'];\n  const cards = [];\n  for (let i = 0; i < 15; i++) {\n    const noteIndex = Math.floor(Math.random() * notes.length);\n    const accidentalIndex = Math.floor(Math.random() * accidentals.length);\n    const keySignatureIndex = Math.floor(Math.random() * keySignatures.length);\n    const timeSignatureIndex = Math.floor(Math.random() * timeSignatures.length);\n\n    // Skip invalid combinations like B# and Cb\n    if (notes[noteIndex] === 'B' && accidentals[accidentalIndex] === '#' || notes[noteIndex] === 'C' && accidentals[accidentalIndex] === 'b' || notes[noteIndex] === 'E' && accidentals[accidentalIndex] === '#' || notes[noteIndex] === 'F' && accidentals[accidentalIndex] === 'b') {\n      i--;\n      continue;\n    }\n    const card = {\n      id: `card-${i + 1}`,\n      note: {\n        letter: notes[noteIndex],\n        accidental: accidentals[accidentalIndex],\n        octave: Math.floor(Math.random() * 3) + 3,\n        // Octaves 3-5\n        keySignature: keySignatures[keySignatureIndex],\n        timeSignature: timeSignatures[timeSignatureIndex]\n      },\n      correctCount: 0,\n      incorrectCount: 0\n    };\n    cards.push(card);\n  }\n  return cards;\n}\nexport const useFlashCardStore = defineStore('flashCard', {\n  state: () => ({\n    decks: [],\n    currentDeck: null,\n    currentCard: null,\n    cardHistory: [],\n    isLoading: false,\n    error: null\n  }),\n  getters: {\n    allDecks: state => state.decks,\n    hasError: state => state.error !== null,\n    errorMessage: state => state.error\n  },\n  actions: {\n    async fetchDecks() {\n      this.isLoading = true;\n      this.error = null;\n      try {\n        // In a real app, we would call the API\n        // const response = await axios.get('/api/decks')\n        // this.decks = response.data\n\n        // Mock data for now\n        this.decks = [{\n          id: '1',\n          name: 'Grand Staff Notes',\n          description: 'Learn to identify notes on the grand staff',\n          cardCount: 42\n        }];\n      } catch (error) {\n        this.error = error.message || 'Failed to fetch decks';\n      } finally {\n        this.isLoading = false;\n      }\n    },\n    async fetchDeck(deckId) {\n      this.isLoading = true;\n      this.error = null;\n      try {\n        // In a real app, we would call the API\n        // const response = await axios.get(`/api/decks/${deckId}`)\n        // this.currentDeck = response.data\n\n        // Mock data for now\n        this.currentDeck = {\n          id: '1',\n          name: 'Grand Staff Notes',\n          description: 'Learn to identify notes on the grand staff',\n          cards: generateMockCards()\n        };\n      } catch (error) {\n        this.error = error.message || 'Failed to fetch deck';\n      } finally {\n        this.isLoading = false;\n      }\n    },\n    getNextCard() {\n      if (!this.currentDeck || !this.currentDeck.cards || this.currentDeck.cards.length === 0) {\n        this.error = 'No cards available';\n        return;\n      }\n\n      // Get a random card from the deck\n      const randomIndex = Math.floor(Math.random() * this.currentDeck.cards.length);\n      this.currentCard = this.currentDeck.cards[randomIndex];\n      this.cardHistory.push(this.currentCard);\n    },\n    async submitAnswer({\n      cardId,\n      answer,\n      isCorrect\n    }) {\n      if (!this.currentDeck || !this.currentCard) {\n        this.error = 'No active card';\n        return;\n      }\n      try {\n        // In a real app, we would call the API\n        // await axios.post(`/api/decks/${this.currentDeck.id}/cards/${cardId}/answer`, {\n        //   answer,\n        //   isCorrect\n        // })\n\n        // If the answer was wrong, we would handle reshuffling the card\n        if (!isCorrect) {\n          // In a real app, this would be handled by the backend\n          // For now, we'll just get the next card\n        }\n\n        // Get the next card\n        this.getNextCard();\n      } catch (error) {\n        this.error = error.message || 'Failed to submit answer';\n      }\n    },\n    clearCardHistory() {\n      this.cardHistory = [];\n    }\n  }\n});","map":{"version":3,"names":["defineStore","axios","generateMockCards","notes","accidentals","keySignatures","timeSignatures","cards","i","noteIndex","Math","floor","random","length","accidentalIndex","keySignatureIndex","timeSignatureIndex","card","id","note","letter","accidental","octave","keySignature","timeSignature","correctCount","incorrectCount","push","useFlashCardStore","state","decks","currentDeck","currentCard","cardHistory","isLoading","error","getters","allDecks","hasError","errorMessage","actions","fetchDecks","name","description","cardCount","message","fetchDeck","deckId","getNextCard","randomIndex","submitAnswer","cardId","answer","isCorrect","clearCardHistory"],"sources":["C:/Users/georg/Documents/Projects/Cursor Tutorial/GrandStaffFlashCards/Frontend/src/stores/flashCardStore.js"],"sourcesContent":["import { defineStore } from 'pinia'\r\nimport axios from 'axios'\r\n\r\n// Helper function to generate mock cards\r\nfunction generateMockCards() {\r\n  const notes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\r\n  const accidentals = ['', '#', 'b'] // Natural, Sharp, Flat\r\n  const keySignatures = ['C Major', 'G Major', 'F Major']\r\n  const timeSignatures = ['4/4', '3/4', '6/8']\r\n  \r\n  const cards = []\r\n  \r\n  for (let i = 0; i < 15; i++) {\r\n    const noteIndex = Math.floor(Math.random() * notes.length)\r\n    const accidentalIndex = Math.floor(Math.random() * accidentals.length)\r\n    const keySignatureIndex = Math.floor(Math.random() * keySignatures.length)\r\n    const timeSignatureIndex = Math.floor(Math.random() * timeSignatures.length)\r\n    \r\n    // Skip invalid combinations like B# and Cb\r\n    if ((notes[noteIndex] === 'B' && accidentals[accidentalIndex] === '#') ||\r\n        (notes[noteIndex] === 'C' && accidentals[accidentalIndex] === 'b') ||\r\n        (notes[noteIndex] === 'E' && accidentals[accidentalIndex] === '#') ||\r\n        (notes[noteIndex] === 'F' && accidentals[accidentalIndex] === 'b')) {\r\n      i--\r\n      continue\r\n    }\r\n    \r\n    const card = {\r\n      id: `card-${i + 1}`,\r\n      note: {\r\n        letter: notes[noteIndex],\r\n        accidental: accidentals[accidentalIndex],\r\n        octave: Math.floor(Math.random() * 3) + 3, // Octaves 3-5\r\n        keySignature: keySignatures[keySignatureIndex],\r\n        timeSignature: timeSignatures[timeSignatureIndex]\r\n      },\r\n      correctCount: 0,\r\n      incorrectCount: 0\r\n    }\r\n    \r\n    cards.push(card)\r\n  }\r\n  \r\n  return cards\r\n}\r\n\r\nexport const useFlashCardStore = defineStore('flashCard', {\r\n  state: () => ({\r\n    decks: [],\r\n    currentDeck: null,\r\n    currentCard: null,\r\n    cardHistory: [],\r\n    isLoading: false,\r\n    error: null\r\n  }),\r\n  \r\n  getters: {\r\n    allDecks: (state) => state.decks,\r\n    hasError: (state) => state.error !== null,\r\n    errorMessage: (state) => state.error\r\n  },\r\n  \r\n  actions: {\r\n    async fetchDecks() {\r\n      this.isLoading = true\r\n      this.error = null\r\n      \r\n      try {\r\n        // In a real app, we would call the API\r\n        // const response = await axios.get('/api/decks')\r\n        // this.decks = response.data\r\n        \r\n        // Mock data for now\r\n        this.decks = [\r\n          {\r\n            id: '1',\r\n            name: 'Grand Staff Notes',\r\n            description: 'Learn to identify notes on the grand staff',\r\n            cardCount: 42\r\n          }\r\n        ]\r\n      } catch (error) {\r\n        this.error = error.message || 'Failed to fetch decks'\r\n      } finally {\r\n        this.isLoading = false\r\n      }\r\n    },\r\n    \r\n    async fetchDeck(deckId) {\r\n      this.isLoading = true\r\n      this.error = null\r\n      \r\n      try {\r\n        // In a real app, we would call the API\r\n        // const response = await axios.get(`/api/decks/${deckId}`)\r\n        // this.currentDeck = response.data\r\n        \r\n        // Mock data for now\r\n        this.currentDeck = {\r\n          id: '1',\r\n          name: 'Grand Staff Notes',\r\n          description: 'Learn to identify notes on the grand staff',\r\n          cards: generateMockCards()\r\n        }\r\n      } catch (error) {\r\n        this.error = error.message || 'Failed to fetch deck'\r\n      } finally {\r\n        this.isLoading = false\r\n      }\r\n    },\r\n    \r\n    getNextCard() {\r\n      if (!this.currentDeck || !this.currentDeck.cards || this.currentDeck.cards.length === 0) {\r\n        this.error = 'No cards available'\r\n        return\r\n      }\r\n      \r\n      // Get a random card from the deck\r\n      const randomIndex = Math.floor(Math.random() * this.currentDeck.cards.length)\r\n      this.currentCard = this.currentDeck.cards[randomIndex]\r\n      this.cardHistory.push(this.currentCard)\r\n    },\r\n    \r\n    async submitAnswer({ cardId, answer, isCorrect }) {\r\n      if (!this.currentDeck || !this.currentCard) {\r\n        this.error = 'No active card'\r\n        return\r\n      }\r\n      \r\n      try {\r\n        // In a real app, we would call the API\r\n        // await axios.post(`/api/decks/${this.currentDeck.id}/cards/${cardId}/answer`, {\r\n        //   answer,\r\n        //   isCorrect\r\n        // })\r\n        \r\n        // If the answer was wrong, we would handle reshuffling the card\r\n        if (!isCorrect) {\r\n          // In a real app, this would be handled by the backend\r\n          // For now, we'll just get the next card\r\n        }\r\n        \r\n        // Get the next card\r\n        this.getNextCard()\r\n      } catch (error) {\r\n        this.error = error.message || 'Failed to submit answer'\r\n      }\r\n    },\r\n    \r\n    clearCardHistory() {\r\n      this.cardHistory = []\r\n    }\r\n  }\r\n}) "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}